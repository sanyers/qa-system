(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["vue-router-data"],{"04fa":function(r,n,e){"use strict";e.r(n),n["default"]="\r\n## vue-router 的理解\r\n\r\n在 vue-router 中，可以通过三种方式来实现前端路由的变化，分别为 hash、history 和 abstract。\r\n\r\n1. hash\r\n\r\nhash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，最重要的是改变 URL 中的 hash 部分不会引起页面刷新。通过 hashchange 事件监听 URL 的变化\r\n\r\n2. history\r\n\r\n由于 html5 标准的发布，history 的 api 增加了两个 API。pushState 和 replaceState。通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 popstate 事件。\r\n\r\n我们主要说几个注意点：\r\n\r\n- 通过 pushState/replaceState 或`<a>`标签改变 URL 不会触发页面刷新，也不会触发 popstate 方法。所以我们可以拦截 pushState/replaceState 的调用和`<a>`标签的点击事件来检测 URL 变化，从而触发 router-view 的视图更新。\r\n- 通过浏览器前进后退改变 URL ，或者通过 js 调用 history 的 back，go，forward 方法，都会触发 popstate 事件，所以我们可以监听 popstate 来触发 router-view 的视图更新。\r\n\r\n所以，我们其实是需要监听 popstate 以及拦截 pushState/placeState 以及 a 的点击去实现监听 URL 的变化。\r\n\r\n3. abstract\r\n\r\nabstract 是 vue 路由中的第三种模式，支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。\r\n"},1145:function(r,n,e){"use strict";e.r(n),n["default"]="## vue router 几种方式实现\r\n\r\nxxx"},4634:function(r,n,e){"use strict";e.r(n),n["default"]="## vue-router 原理\r\n\r\nxxx"},b9a2:function(r,n,e){"use strict";e.r(n),n["default"]="## vue router 分层\r\n\r\nxxx"},c299:function(r,n,e){"use strict";e.r(n),n["default"]='## vue-router 懒加载原理\r\n\r\n官方：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。\r\n\r\n一句话就是动态 import 代码分割 + jsonp\r\n\r\n运行主程序 => 加载主包代码 => 点击懒加载模块 => 拼接对应模块的路径 => 动态插入 script 标签 => 执行 script 脚本，调用 webpackJsonpCallback 方法 => 将懒加载的模块注册到 `__webpack_modules__` => 调用模块\r\n\r\n1、import() 方法\r\n\r\n路由懒加载也可以叫做路由组件懒加载，最常用的是通过 `import()` 来实现它。\r\n\r\n然后通过 Webpack 编译打包后，会把每个路由组件的代码分割成一一个 js 文件，初始化时不会加载这些 js 文件，只当激活路由组件才会去加载对应的 js 文件。\r\n\r\n2、webpackChunkName\r\n\r\n在 import 函数中配置 webpackChunkName，使编译打包后的 js 文件名字能和路由组件一一对应。\r\n\r\n3、资源加载\r\n\r\n资源加载先用 link 定义 Home.js、app.js、chunk-vendors.js 这些资源和 web 客户端的关系。\r\n\r\n- `ref=preload`：告诉浏览器这个资源要给我提前加载。\r\n- `rel=prefetch`：告诉浏览器这个资源空闲的时候给我加载一下。\r\n- `as=script`：告诉浏览器这个资源是script，提升加载的优先级。\r\n\r\n然后在 body 里面加载了 chunk-vendors.js、app.js 这两个 js 资源。可以看出web客户端初始化时候就加载了这个两个 js 资源。\r\n\r\n4、打包后的资源\r\n\r\n```js\r\n// 组件包\r\n(function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\neval("\\n\\nnew Promise(function (resolve) {...}");\r\n\r\n/***/ })\r\n\r\n// webpackJsonp\r\n(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{\r\n/***/ "./src/a.js":(function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\neval(\'...\');\r\n\r\n/***/ })\r\n\r\n}]);\r\n\r\n// webpackJsonp\r\nvar jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];\r\nvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\r\njsonpArray.push = webpackJsonpCallback;\r\n```\r\n\r\n5、参考\r\n\r\nhttps://v3.router.vuejs.org/zh/guide/advanced/lazy-loading.html\r\n\r\nhttps://juejin.cn/post/6844904013842874376\r\n\r\nhttps://juejin.cn/post/6844904180285456398\r\n\r\nhttps://juejin.cn/post/6924484965073862664'}}]);