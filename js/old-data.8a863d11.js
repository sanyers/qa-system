(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["old-data"],{"0178":function(r,n,e){"use strict";e.r(n),n["default"]="## 数组合并有几种方式\r\n\r\n（1）for\r\n\r\n会变更原数组，当然也可以写成生成新数组的形式。\r\n\r\n```js\r\nlet arr = [1, 2]\r\nlet arr2 = [3, 4]\r\n\r\nfor (let i in arr2) {\r\n    arr.push(arr2[i])\r\n}\r\n\r\nconsole.log(arr)\r\n// [1, 2, 3, 4]\r\n```\r\n\r\n（2）concat\r\n\r\n会生成新的数组。\r\n\r\n```js\r\nlet arr = [1, 2]\r\nlet arr2 = [3, 4]\r\n\r\narr = arr.concat(arr2)\r\n\r\nconsole.log(arr)\r\n// [1, 2, 3, 4]\r\n```\r\n\r\n（3）arr.push.apply\r\n\r\n会变更原数组。\r\n\r\n```js\r\nlet arr = [1, 2]\r\nlet arr2 = [3, 4]\r\n\r\narr.push.apply(arr, arr2)\r\n\r\nconsole.log(arr)\r\n// [1, 2, 3, 4]\r\n```\r\n\r\n（4）[…arr, …arr2]\r\n\r\n会生成新的数组。\r\n\r\n```js\r\nlet arr = [1, 2]\r\nlet arr2 = [3, 4]\r\n\r\narr = [...arr, ...arr2]\r\n\r\nconsole.log(arr)\r\n// [1, 2, 3, 4]\r\n```\r\n\r\n（5）push(…arr)\r\n\r\n会变更原数组。\r\n\r\n```js\r\nlet arr = [1, 2]\r\nlet arr2 = [3, 4]\r\n\r\narr.push(...arr2)\r\n\r\nconsole.log(arr)\r\n// [1, 2, 3, 4]\r\n```\r\n\r\n参考：\r\n\r\nhttps://blog.csdn.net/github_35780607/article/details/110528481"},"0515":function(r,n,e){"use strict";e.r(n),n["default"]="## vue 的动态组件，异步组件\r\n\r\n动态组件：\r\n\r\n- 让多个组件同使用一个挂载点，并且组件间可以动态切换，这个挂载点就是 **component 标签**\r\n- 简单来说是在 component 标签上添加一个**is属性**，属性值（即currentTabComponent）是控制组件间的切换的\r\n- 可配合 `keep-alive` 使用，这样切换的时候就可以不用频繁渲染\r\n  - 1. keep-alive 是vue的内置组件，可以包含动态组件，当组件之间进行切换时，可以保持组件的状态，在内存中缓存不活动组件的实例，而不是销毁它们）\r\n  - 2. 并且自身也不会渲染成一个DOM元素，不会显示在父组件链中\r\n\r\n规则：语法:`is='compoent-name'` 动态对应 data 中对应的组件值\r\n\r\n异步组件：\r\n\r\n- vue 的一种性能优化的方法，可以实现组件的**按需加载**\r\n- 组件通过 `import` 函数引用，什么时候需要什么时候加载\r\n- 有利于项目的性能优化，**提高**页面的**加载速度**\r\n- **路由懒加载**就是使用了异步组件的原理\r\n\r\n规则：使用 import 引入\r\n\r\n```js\r\ncomponents: {\r\n  IsAsyncDemo: () => import('./IsAsyncD.vue')\r\n},\r\n```\r\n\r\n参考：https://blog.csdn.net/weixin_38318244/article/details/124159225"},"082b":function(r,n,e){"use strict";e.r(n),n["default"]="## JavaScript原型，原型链 ? 有什么特点？\r\n\r\n- 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。\r\n- 关系：instance.constructor.prototype = instance.proto\r\n- 特点：\r\n  JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。"},"0970":function(r,n,e){"use strict";e.r(n),n["default"]="## v-if 和 v-show 的区别\r\n\r\n- `v-if` 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。\r\n- `v-show` 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）\r\n\r\n使用场景\r\n\r\n- `v-if` 适用于在运行时很少改变条件，不需要频繁切换条件的场景\r\n- `v-show` 适用于需要非常频繁切换条件的场景\r\n\r\n扩展补充：display:none、visibility:hidden 和 opacity:0 之间的区别？\r\n\r\n三者共同点都是隐藏。不同点：\r\n\r\n| 属性 | 占据空间 | 元素继承 | 事件绑定 | 过渡动画 |\r\n| :----: | :----: | :----: | :----: | :----: |\r\n| display:none | 不占据位置 | 不会被子元素继承 | 不会触发事件 | transition 动画无效 |\r\n| visibility:hidden | 占据位置 | 会继承，通过设置子元素 visibility:visible 来显示子元素 | 不会触发事件 | transition 动画无效 |\r\n| opacity:0 | 占据位置 | 会继承，但不能设置子元素 opacity:0 来重新显示 | 会触发事件 | transition 动画有效 |"},"0be8":function(r,n,e){"use strict";e.r(n),n["default"]="## vue有什么性能问题，以及Vue的性能优化有哪些？\r\n\r\n（1）代码层面的优化\r\n\r\n- 数据层级不要过深，合理的设置响应式数据\r\n- 使用数据时，缓存值的结果，不频繁取值\r\n- v-for合理设置key\r\n- v-show(频繁切换性能高)和v-if的合理使用\r\n- 控制组件的粒度 -> Vue采用组件级别更新\r\n- 采用函数式组件 -> 函数式组价开销低\r\n- 采用异步组件 -> 借助webpack的分包策略\r\n- 事件的销毁\r\n- 图片和路由的懒加载\r\n- 第三方插件的按需引入\r\n- 使用keep-alive来缓存组件\r\n- 虚拟滚动、时间分片等策略\r\n- 服务端渲染 ssr 或者预渲染\r\n\r\n（2）Webpack 打包的优化\r\n\r\n- 图片压缩\r\n- 减少 ES6 转为 ES5 的冗余代码\r\n- 提取公共代码\r\n- 模板预编译\r\n- 提取组件的 CSS\r\n- 优化 SourceMap\r\n- 编译优化\r\n\r\n（3）Web 技术的优化\r\n\r\n- 开启 gzip 压缩\r\n- 浏览器缓存\r\n- CDN 的使用"},1081:function(r,n,e){"use strict";e.r(n),n["default"]="## 介绍一下 CSS 的盒子模型？\r\n\r\n有两种， IE 盒子模型、W3C 盒子模型；\r\n\r\n盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\r\n\r\n区 别： IE 的 content 部分把 border 和 padding 计算了进去;"},1796:function(r,n,e){"use strict";e.r(n),n["default"]="## 什么是 JavaScript 中的包装类型？\r\n\r\n为了方便操作原始值，JavaScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。\r\n\r\n每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。"},"1bf2":function(r,n,e){"use strict";e.r(n),n["default"]="## v-html会导致什么问题\r\n\r\nhtml指令存在的xss漏洞\r\n\r\n1. 引入xss包并挂载到vue原型上\r\n2. 在vue.config.js中覆写html指令\r\n"},"1f27":function(r,n,e){"use strict";e.r(n),n["default"]="## 判断数组的方式有哪些？\r\n\r\n```js\r\n// 1. 通过 instanceof 判定\r\narr instanceof Array\r\n\r\n// 2. 通过 constructor 判定\r\narr.constructor == Array\r\n\r\n// 3. Object.protype.toString.call 判定\r\nObject.protype.toString.call(arr) == '[Object Array]'\r\n\r\n// 4. 通过原型链做判断\r\narr.__proto__ === Array.prototype;\r\n\r\n// 5. 通过 ES6 的 Array.isArray() 做判断\r\nArray.isArrray(arr);\r\n\r\n// 6. 通过 Array.prototype.isPrototypeOf 判定\r\nArray.prototype.isPrototypeOf(arr)\r\n```"},"20d3":function(r,n,e){"use strict";e.r(n),n["default"]="## vue的diff算法原理是什么?\r\n\r\nVue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较\r\n\r\n- 先比较两个节点是不是相同节点\r\n- 相同节点比较属性，复用老节点\r\n- 先比较儿子节点，考虑老节点和新节点儿子的情况\r\n- 优化比较：头头、尾尾、头尾、尾头\r\n- 比对查找，进行复用"},"218b":function(r,n,e){"use strict";e.r(n),n["default"]="## js 的数据类型的转换\r\n\r\n在 JS 中类型转换只有三种情况，分别是：\r\n\r\n- 转换为布尔值（调用 Boolean() 方法）\r\n- 转换为数字（调用 Number()、parseInt() 和 parseFloat() 方法）\r\n- 转换为字符串（调用 .toString() 或者 String() 方法）\r\n\r\n> null 和 underfined 没有 .toString 方法"},"24af":function(r,n,e){"use strict";e.r(n),n["default"]="## vue中的key以及v-for为什么要加key\r\n\r\n- Vue在patch过程中，通过key可以判断两个虚拟节点是否是相同节点。\r\n- 没有key会导致更新的时候出问题\r\n- 尽量不要采用索引作为key"},"2aab":function(r,n,e){"use strict";e.r(n),n["default"]="## typeof null 的结果是什么，为什么？\r\n\r\ntypeof null 的结果是 Object。\r\n\r\n在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：\r\n\r\n```\r\n000: object   - 当前存储的数据指向一个对象。\r\n  1: int      - 当前存储的数据是一个 31 位的有符号整数。\r\n010: double   - 当前存储的数据指向一个双精度的浮点数。\r\n100: string   - 当前存储的数据指向一个字符串。\r\n110: boolean  - 当前存储的数据是布尔值。\r\n```\r\n\r\n如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。\r\n\r\n有两种特殊数据类型：\r\n\r\n- undefined 的值是 (-2)30(一个超出整数范围的数字)；\r\n- null 的值是机器码 NULL 指针空对象(null 指针的值全是 0)\r\n\r\n那也就是说 null 的类型标签也是 000，和 Object 的类型标签一样，所以会被判定为 Object。"},"2ca7":function(r,n,e){"use strict";e.r(n),n["default"]="## Vue 响应式数据的原理\r\n\r\nvue2.0：\r\n\r\n整体思路是数据劫持+观察者模式\r\n\r\n数组和对象类型的值变化的时候，通过 defineReactive 内部方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性，getter，setter）。当页面使用对应属性时，每个属性在 getter 时调用 dep.depend 收集依赖，setter 调用 dep.nottify 通知更新，Dep.nottify 调用 watcher.update 方法去更新，然后就进入了异步更新阶段\r\n\r\n数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)\r\n\r\n所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新\r\n\r\nvue3.0：\r\n\r\nVue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化"},"2ff9":function(r,n,e){"use strict";e.r(n),n["default"]="## 虚拟 DOM 是什么 有什么优缺点\r\n\r\n- 虚拟dom就是用js对象来描述真实Dom，是对真实Dom的抽象\r\n- 由于直接操作Dom性能低，但是js层的操作效率高，可以将Dom操作转化成对象操作。最终通过diff算法比对差异进行更新Dom\r\n- 虚拟Dom不依赖真实平台环境，可以实现跨平台\r\n\r\n由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。\r\n\r\nVirtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。\r\n\r\n优点：\r\n\r\n- 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；\r\n- 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；\r\n- 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。\r\n\r\n缺点:\r\n\r\n- 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。\r\n- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\r\n"},3031:function(r,n,e){"use strict";e.r(n),n["default"]="## == 操作符的强制类型转换规则？\r\n\r\n对于 == 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程：\r\n\r\n1. 首先会判断两者类型是否相同，相同的话就比较两者的大小；\r\n2. 类型不相同的话，就会进行类型转换；\r\n3. 会先判断是否在对比 null 和 undefined，是的话就会返回 true\r\n4. 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number\r\n5. 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断\r\n6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断\r\n\r\n`1 == '1'` => `1 == 1`\r\n\r\n`'1' == true` => `'1' == 1` => `1  ==  1`\r\n\r\n`'1' == { name: 'js' }` => `'1' == '[object Object]'`"},3161:function(r,n,e){"use strict";e.r(n),n["default"]="## document.write 和 innerHTML 的区别？\r\n\r\n- `document.write` 只能重绘整个页面\r\n- `innerHTML` 可以重绘页面的一部分"},3285:function(r,n,e){"use strict";e.r(n),n["default"]='## directive 的实现\r\n\r\n指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。\r\n\r\n自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind\r\n\r\n1. 钩子函数\r\n\r\n- `bind` 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\r\n- `inserted` 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\r\n- `update` 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。\r\n- `componentUpdated` 指令所在组件的 VNode 及其子 VNode 全部更新后调用。\r\n- `unbind` 只调用一次，指令与元素解绑时调用。\r\n\r\n2. 钩子函数参数\r\n\r\n- `el` 指令所绑定的元素，可以用来直接操作 DOM\r\n- `binding`   一个对象，包含以下属性：\r\n  - `name`：指令名，不包括 v- 前缀。\r\n  - `value`：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。\r\n  - `oldValue`：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\r\n  - `expression`：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。\r\n  - `arg`：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。\r\n  - `modifiers`：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\r\n- `vnode`：Vue 编译生成的虚拟节点。\r\n- `oldVnode`：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\r\n\r\n除了 el 之外，其它参数都应该是只读的，切勿进行修改。\r\n\r\n原理：\r\n\r\n- 在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性\\\r\n- 通过 genDirectives 生成指令代码\r\n- 在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子\r\n- 当执行指令对应钩子函数时，调用对应指令定义的方法\r\n\r\n3. 应用场景\r\n\r\n- 自动获取焦点\r\n- 一键 Copy 的功能\r\n- 按钮级别权限控制'},"341c":function(r,n,e){"use strict";e.r(n),n["default"]="## 简述一下你对 HTML 语义化的理解？\r\n\r\n- 用正确的标签做正确的事情。\r\n- html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\r\n- 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;\r\n- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。"},3535:function(r,n,e){"use strict";e.r(n),n["default"]="## 介绍一下闭包和闭包常用场景？\r\n\r\n- 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数\r\n- 使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。\r\n- 闭包有三个特性：\r\n  - 函数嵌套函数\r\n  - 函数内部可以引用外部的参数和变量\r\n  - 参数和变量不会被垃圾回收机制回收\r\n- 应用场景，设置私有变量的方法\r\n- 不适用场景：返回闭包的函数是个非常大的函数\r\n- 闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏"},3870:function(r,n,e){"use strict";e.r(n),n["default"]="## vue 的生命周期钩子\r\n\r\n重点：`beforeCreate` -> `created` -> `beforeMount` -> `mounted` -> `beforeUpdate` -> `updated` -> `beforeDestory` -> `destoryed`\r\n\r\n- `beforeCreate`\r\n\r\n1. 初始化了部分参数（调用 initInternalComponent），如果有相同的参数，做了参数合并（调用 mergeOptions）\r\n2. 初始化组件实例关系属性，比如 $parent、$children、$root、$refs、$router、$store 等（调用 initLifecycle)\r\n3. 初始化自定义事件(调用 initEvents)\r\n4. 解析组件的插槽信息，得到 vm.$slot，处理渲染函数，得到 vm.$createElement 方法，即 h 函数（调用 initRender）\r\n5. 执行 beforeCreate钩子\r\n\r\n- `created`\r\n\r\n1. 初始化组件的 inject 配置项(调用 initInjections)\r\n2. 数据响应式的重点，处理 props、methods、data、computed、watch(调用 initState)\r\n3. 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上(调用 initProvide)\r\n4. 执行 created 钩子\r\n\r\n- `beforeMount`\r\n\r\n检查是否存在 el 属性，存在的话进行渲染 dom 操作，执行 beforeMount (这个里面基本没什么操作)\r\n\r\n- `mounted`\r\n\r\n实例化 Watcher ，渲染 dom，执行 mounted\r\n\r\n- `beforeUpdate`\r\n\r\n在渲染 dom 后，执行了 mounted 钩子后，在数据更新的时候，执行 beforeUpdate\r\n\r\n- `updated`\r\n\r\n检查当前的 watcher 列表中，是否存在当前要更新数据的 watcher ，如果存在就执行 updated\r\n\r\n- `beforeDestroy`\r\n\r\n检查是否已经被卸载，如果已经被卸载，就直接 return 出去，否则执行 beforeDestroy\r\n\r\n- `destroyed`\r\n\r\n把所有有关自己痕迹的地方，都给删除掉\r\n\r\n- `activated` \r\n\r\nkeep-alive 专属，组件被激活时调用\r\n\r\n- `deactivated` \r\n\r\nkeep-alive 专属，组件被销毁时调用"},"3b16":function(r,n,e){"use strict";e.r(n),n["default"]="## 判断一个值是什么类型有哪些方法？\r\n\r\n类型检查有四种方式，分别为 typeof、instanceof、constructor 和 Object.prototype.toString()。\r\n\r\n```js\r\n// 通过 typeof 操作符来判断一个值属于哪种原始类型\r\ntypeof 'seymoe' // 'string'\r\n\r\n// 通过 instanceof 操作符可以对引用类型进行判定\r\n[] instanceof Array // true\r\n\r\n// 通过 constructor 构造器返回数据类型\r\n(2).constructor === Number // true\r\n\r\n// 通过 Object.prototype.toString() 可以判定 JavaScript 中所有数据类型\r\nObject.prototype.toString.call({}) // '[object Object]'\r\n```"},"3c85":function(r,n,e){"use strict";e.r(n),n["default"]="## Vue 的父组件和子组件生命周期钩子函数执行顺序？\r\n\r\nVue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：\r\n\r\n- 加载渲染过程：\r\n父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted\r\n\r\n- 子组件更新过程 :\r\n\r\n父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated\r\n\r\n- 父组件更新过程 :\r\n\r\n父 beforeUpdate -> 父 updated\r\n\r\n- 销毁过程 :\r\n\r\n父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed"},"3c8f":function(r,n,e){"use strict";e.r(n),n["default"]="## v-if 与 v-for 为什么不建议一起使用\r\n\r\nv-for 和 v-if 不要在同一个标签中使用,因为解析时先解析 v-for 再解析 v-if。如果遇到需要同时使用时可以考虑写成计算属性的方式。"},"3dc6":function(r,n,e){"use strict";e.r(n),n["default"]="## vue中模版编译原理\r\n\r\n首先，vue 提供了两个构建版本：\r\n\r\n- vue.js： 完整版本，包含了模板编译的能力；\r\n- vue.runtime.js： 运行时版本，不提供模板编译能力，需要通过 vue-loader 进行提前编译。\r\n\r\n模板编译主要是在 createCompiler 方法中实现，实现的最终结果是将 template 中的代码，转化为类似 render 函数的输出形式。\r\n\r\n其中，主要包含三个步骤：\r\n\r\n1. 模板编译，通过调用 parse 方法，将模板代码转化为 AST（抽象语法树），转化后的 AST 是一个树形结构的对象，其中包含 tag(标签名)，type(标签类型)，start(在 html 中的开始位置)，end(在 html 中的结束位置)，children(子节点)，attrsList(标签属性)，attrsMap(标签映射)等属性；\r\n\r\n2. 通过调用 optimize 方法，主要是为了优化 AST，确保静态的数据不会进入虚拟 DOM 的更新阶段，以此来优化性能。简单来说，就是把所有静态节点的 static 属性设置为 true。\r\n\r\n3. 通过调用 generate 方法，将 AST 转化为 render 方法。\r\n\r\n转换成 render 以后，那么编译过程就结束了，接下来就是将 render 转换成虚拟 dom，然后生成 watcher，创建 updateComponent 等等。。。\r\n\r\n也就是说，直接通过render的形式返回的，是不需要做模板编译的。"},"425c":function(r,n,e){"use strict";e.r(n),n["default"]="## rgba和opacity的透明效果有什么不同？\r\n\r\nopacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。"},"42fb":function(r,n,e){"use strict";e.r(n),n["default"]="## 模版编译变量如何匹配\r\n\r\nxxx"},"456a":function(r,n,e){"use strict";e.r(n),n["default"]='## undefined 与 undeclared 的区别？\r\n\r\n- 已在作用域中声明但还没有赋值的变量，是 undefined。\r\n- 相反，还没有在作用域中声明过的变量，是 undeclared 的。\r\n\r\n```js\r\nfunction foo() {\r\n  "use strict";\r\n  bar = true;\r\n}\r\nfoo(); // ReferenceError: assignment to undeclared variable bar\r\n```\r\n\r\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。'},"47a4":function(r,n,e){"use strict";e.r(n),n["default"]="## $refs 是如何实现的\r\n\r\nref 被用来给DOM元素或子组件注册引用信息。引用信息会根据父组件的 $refs 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例。\r\n\r\n> 注意： $refs只有在组件渲染完成后才填充，在初始渲染的时候不能访问它们，并且它是非响应式的，因此不能用它在模板中做数据绑定"},"485c":function(r,n,e){"use strict";e.r(n),n["default"]="## computed 和 watch 的区别和运用的场景\r\n\r\ncomputed 和 watch 都是基于 watcher 来实现的\r\n\r\ncomputed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。\r\n\r\nwatch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。"},"4d49":function(r,n,e){"use strict";e.r(n),n["default"]="## Vue 修饰符有哪些\r\n\r\n事件修饰符\r\n\r\n- .stop 阻止事件继续传播\r\n- .prevent 阻止标签默认行为\r\n- .capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理\r\n- .self 只当在 event.target 是当前元素自身时触发处理函数\r\n- .once 事件将只会触发一次\r\n- .passive 告诉浏览器你不想阻止事件的默认行为\r\n\r\nv-model 的修饰符\r\n\r\n- .lazy 通过这个修饰符，转变为在 change 事件再同步\r\n- .number 自动将用户的输入值转化为数值类型\r\n- .trim 自动过滤用户输入的首尾空格\r\n\r\n\r\n键盘事件的修饰符\r\n\r\n- .enter\r\n- .tab\r\n- .delete (捕获“删除”和“退格”键)\r\n- .esc\r\n- .space\r\n- .up\r\n- .down\r\n- .left\r\n- .right\r\n\r\n系统修饰键\r\n\r\n- .ctrl\r\n- .alt\r\n- .shift\r\n- .meta\r\n\r\n鼠标按钮修饰符\r\n\r\n- .left\r\n- .right\r\n- .middle\r\n"},"4db8":function(r,n,e){"use strict";e.r(n),n["default"]='## script 的 async 和 defer\r\n\r\n`<script>` 元素有下列 8 个属性：\r\n\r\n- `async`：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。\r\n- `defer`：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。\r\n- `charset`：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。\r\n- `crossorigin`：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。\r\n  - `crossorigin="anonymous"` 配置文件请求不必设置凭据标志。\r\n  - `crossorigin="use-credentials"` 设置凭据标志，意味着出站请求会包含凭据。\r\n- `integrity`：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。\r\n- `language`：废弃。最初用于表示代码块中的脚本语言（如"JavaScript"、"JavaScript 1.2"或"VBScript"）。大多数浏览器都会忽略这个属性，不应该再使用它。\r\n- `src`：可选。表示包含要执行的代码的外部文件。\r\n- `type`：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。'},"4f38":function(r,n,e){"use strict";e.r(n),n["default"]="## 组件中 data 为什么是一个函数\r\n\r\n重点：可复用组件 data 是一个函数，每次使用 data 都将返回一个对象的独立的拷贝，组件之间互不影响\r\n\r\n为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？\r\n\r\n- 因为组件是用来复用的，且 JS 里对象是**引用类型**\r\n- 如果组件中 data 是一个对象，这样作用域就没有隔离，子组件中的 data 属性值会相互影响\r\n- 如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响\r\n- 而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。\r\n\r\n组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果\r\n"},"504c":function(r,n,e){"use strict";e.r(n),n["default"]="## 标签上 title 与 alt 属性的区别是什么？\r\n\r\n- alt 是给搜索引擎识别，在图像无法显示时的替代文本；\r\n- title 是关于元素的注释信息，主要是给用户解读。\r\n- 当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。\r\n- 在定义 img 对象时，将 alt 和 title 属性写全，可以保证在各种浏览器中都能正常使用。"},5678:function(r,n,e){"use strict";e.r(n),n["default"]="## css 选择器优先级？\r\n\r\n!important > 行内样式（比重1000）> ID 选择器（比重100） > 类选择器（比重10） > 标签（比重1） > 通配符 > 继承 > 浏览器默认属性"},5959:function(r,n,e){"use strict";e.r(n),n["default"]="## display:none 和 visibility:hidden 的区别？\r\n\r\n- `display:none` 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\r\n- `visibility:hidden` 隐藏对应的元素，但是在文档布局中仍保留原来的空间。"},"5de2":function(r,n,e){"use strict";e.r(n),n["default"]="## HTML5、里面都新增了那些新特性？\r\n\r\n- 新的语义标签\r\n  - article 独立的内容。\r\n  - aside 侧边栏。\r\n  - header 头部。\r\n  - nav 导航。\r\n  - section 文档中的节。\r\n  - footer 页脚。\r\n- 画布(Canvas) API\r\n- 地理(Geolocation) API\r\n- 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\r\n- sessionStorage 的数据在浏览器关闭后自动删除\r\n- 新的技术webworker, websocket, Geolocation\r\n- 拖拽释放(Drag and drop) API\r\n- 音频、视频API(audio,video)\r\n- 表单控件，calendar、date、time、email、url、searc"},"5ede":function(r,n,e){"use strict";e.r(n),n["default"]="## || 和 && 操作符的返回值？\r\n\r\n|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\r\n\r\n- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\r\n- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\r\n\r\n|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果"},6068:function(r,n,e){"use strict";e.r(n),n["default"]="## 组件中的name属性有哪些作用\r\n\r\n- 递归组件运用（指组件自身组件调用自身组件）\r\n- keep-alive包裹动态组件时，会缓存不活动的组件实例，会出现include和exclude属性，包含或者排除指定name组件\r\n- vue-tools插件调试"},"63d7":function(r,n,e){"use strict";e.r(n),n["default"]='## scoped原理\r\n\r\nvue 中的 scoped 属性的效果主要通过 PostCSS 转译实现\r\n\r\nPostCSS 给一个组件中的所有dom添加了一个独一无二的动态属性，然后，给 CSS 选择器额外添加一个对应的属性选择器来选择该组件中dom，这种做法使得样式只作用于含有该属性的dom——组件内部dom。\r\n\r\n编译前：\r\n\r\n```html\r\n<style>\r\n.example {\r\n color: red;\r\n}\r\n</style>\r\n<template>\r\n <div class="example">hi</div>\r\n</template>\r\n```\r\n\r\n编译后：\r\n\r\n```html\r\n<style>\r\n.example[data-v-4728474d8b] {\r\n color: red;\r\n}\r\n</style>\r\n<template>\r\n <div class="example" data-v-4728474d8b>hi</div>\r\n</template>\r\n```\r\n\r\n参考：https://blog.csdn.net/Rainbow1995/article/details/111835526'},"664b":function(r,n,e){"use strict";e.r(n),n["default"]="## js 数据类型和值是怎么存储的？\r\n\r\nJavaScript 数据类型分为两种：\r\n\r\n- 简单数据类型（也称为原始类型）：一共有 7 种简单类型，String(字符串)，Number(数字)，BigInt(任意大整数)，Boolean(布尔值)，Null(空值)，Undefined(未定义)，Symbol(符号)。\r\n- 复杂数据类型（引用类型）：Object(对象)。\r\n\r\n存储方式：\r\n\r\n- 原始类型把数据名和值直接存储在栈当中\r\n- 引用类型在栈中存储数据名和一个堆的地址，在堆中存储属性及值。访问时先从栈获取地址，再到堆中拿出相应的值。"},"6aa9":function(r,n,e){"use strict";e.r(n),n["default"]="## 请解释一下 JavaScript 的同源策略？\r\n\r\n概念:同源策略是客户端脚本，其目的是防止某个文档或脚本从多个不同源装载。\r\n\r\n这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。\r\n\r\n指一段脚本只能读取来自同一来源的窗口和文档的属性。"},"6d21":function(r,n,e){"use strict";e.r(n),n["default"]="## Object.is() 与比较操作符 “===”、“==” 的区别？\r\n\r\n- ==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型\r\n- ===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型\r\n- 使用 Object.is 来进行相等判断时，一般情况下和 === 的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。"},"6f3b":function(r,n,e){"use strict";e.r(n),n["default"]="## isNaN 和 Number.isNaN 函数的区别？\r\n\r\n- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\r\n- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。"},"70fd":function(r,n,e){"use strict";e.r(n),n["default"]="## Vue 事件绑定原理\r\n\r\n原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。如果要在组件上使用原生事件，需要加.native 修饰符，这样就相当于在父组件中把子组件当做普通 html 标签，然后加上原生事件。\r\n\r\n$on、$emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器"},"72cb":function(r,n,e){"use strict";e.r(n),n["default"]="## JSON 的了解？\r\n\r\n- JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。\r\n- 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小\r\n`{'age':'12', 'name':'back'}`"},7324:function(r,n,e){"use strict";e.r(n),n["default"]="## 判断空对象的 5 种方法\r\n\r\n```js\r\nlet obj = { name: 'hello' };\r\n\r\n// 第一种使用 valueOf()\r\n// 是 true 为空对象，是 false 则不是空对象\r\nconsole.log(obj.valueOf() === '{}'); // false\r\n\r\n// 第二种使用 JSON.stringify()\r\nconsole.log(JSON.stringify(obj) === '{}'); // false\r\n\r\n// 第三种使用 for in\r\nlet isEmpty = true;\r\nfor (let key in obj) {\r\n  isEmpty = false;\r\n}\r\nconsole.log(isEmpty); // false\r\n\r\n// 第四种使用 Object.getOwnPropertyNames()\r\nconst s = Object.getOwnPropertyNames(obj);\r\nconsole.log(s.length > 0); // false\r\n\r\n// 第五种使用 Object.keys()、Object.values()、Object.entries()\r\nconst s = Object.keys(obj);\r\nconsole.log(s.length > 0); // false\r\n```\r\n"},"7dab":function(r,n,e){"use strict";e.r(n),n["default"]="## vue 中使用了哪些设计模式\r\n\r\n1. 工厂模式 - 传入参数即可创建实例，虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode\r\n2. 单例模式 - 整个程序有且仅有一个实例，vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉\r\n3. 发布-订阅模式 (vue 事件机制)\r\n4. 观察者模式 (响应式数据原理)\r\n5. 装饰模式: (@装饰器的用法)\r\n6. 策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略"},"7f76":function(r,n,e){"use strict";e.r(n),n["default"]="## 函数式组件\r\n\r\n函数式组件是指用一个 Function 来渲染一个 vue 组件，这个组件只接受一些 prop，我们可以将这类组件标记为 functional，这意味着它无状态 (没有响应式数据)，也没有实例 (没有this上下文)。\r\n\r\n一个函数式组件大概向下面这样：\r\n\r\n```js\r\nexport default () => {\r\n  functional: true,\r\n  props: {\r\n  // Props 是可选的\r\n  },\r\n  // 为了弥补缺少的实例, 提供第二个参数作为上下文\r\n  render: function (createElement, context) {\r\n    return vNode\r\n  }\r\n }\r\n```\r\n\r\nrender 函数的第二个参数 context 用来代替上下文 this 他是一个包含如下字段的对象：\r\n\r\n- props：提供所有 prop 的对象\r\n- children: VNode 子节点的数组\r\n- slots: 一个函数，返回了包含所有插槽的对象\r\n- scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。\r\n- data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件\r\n- parent：对父组件的引用\r\n- listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。\r\n- injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。\r\n\r\n函数式组件渲染开销低，因为函数式组件只是函数。"},8150:function(r,n,e){"use strict";e.r(n),n["default"]='## typeof NaN 的结果是什么？\r\n\r\nNaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\r\n\r\n```js\r\ntypeof NaN; // "number"\r\n```\r\n\r\nNaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。'},"81bf":function(r,n,e){"use strict";e.r(n),n["default"]="## 使用过 Vue SSR 吗？说说 SSR？\r\n\r\nSSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。\r\n\r\n服务端渲染 SSR 的优缺点如下：\r\n\r\n（1）服务端渲染的优点：\r\n\r\n- 更好的 SEO\r\n- 更快的内容到达时间（首屏加载更快）\r\n\r\n\r\n（2) 服务端渲染的缺点：\r\n\r\n- 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\r\n- 更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。"},"88c2":function(r,n,e){"use strict";e.r(n),n["default"]="## 函数的防抖和节流是什么，有什么区别，以及应用场景？\r\n\r\n1、函数防抖\r\n\r\n指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\r\n\r\n```js\r\n// 防抖\r\nfunction debounce(fn, delay = 500) {\r\n  let timer;\r\n  return function() {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(() => {\r\n      fn.apply(this, arguments);\r\n    }, delay);\r\n  };\r\n}\r\n\r\n// 用法\r\nvar c = 30;\r\nfunction test(a, b) {\r\n  console.log(a, b, c);\r\n}\r\n\r\nconst d = debounce(test);\r\n\r\nd(1, 2);\r\nsetTimeout(() => {\r\n  d(3, 4);\r\n}, 100);\r\n// 3 4 30\r\n```\r\n\r\n2、函数节流\r\n\r\n连续触发事件但是在 n 秒中只执行一次函数。\r\n\r\n```js\r\n// 节流\r\nfunction throttle(fn, delay = 500) {\r\n  let timer;\r\n  return function() {\r\n    if (!timer) {\r\n      timer = setTimeout(() => {\r\n        fn.apply(this, arguments);\r\n      }, delay);\r\n    }\r\n  };\r\n}\r\n\r\n// 用法\r\nvar c = 30;\r\nfunction test(a, b) {\r\n  console.log(a, b, c);\r\n}\r\n\r\nconst d = throttle(test);\r\n\r\nd(1, 2);\r\nsetTimeout(() => {\r\n  d(3, 4);\r\n}, 100);\r\n// 1 2 30\r\n```\r\n\r\n防抖应用场景：\r\n\r\n- search搜索联想，用户在不断输入值时，用防抖来节约请求资源。\r\n- window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次\r\n\r\n节流应用场景：\r\n\r\n- 鼠标不断点击触发，mousedown(单位时间内只触发一次)\r\n- 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断"},"8cdc":function(r,n,e){"use strict";e.r(n),n["default"]="## var、let、const 区别？\r\n\r\n- var 存在变量提升。\r\n- let 只能在块级作用域内访问。\r\n- const 用来定义常量，必须初始化，不能修改（对象特殊）"},"8ec2":function(r,n,e){"use strict";e.r(n),n["default"]="## Vue 的全局 API 有哪些？\r\n\r\n1. Vue.set\r\n\r\n由于 Vue 无法探测普通对象的新增 property 属性，所以通过 Vue.set 为向响应式对象中添加一个 property 属性，可以确保这个新 property 同样是响应式的，且触发视图更新。如果数组则使用 splice 方法更新\r\n\r\n2. Vue.delete\r\n\r\n删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。当然同样不能删除根级别的响应式属性。如果数组则使用 splice 方法更新\r\n\r\n3. Vue.nextTick\r\n\r\n延迟回调函数 cb 的执行，一般用于 this.key = newVal 更改数据后，想立即获取更改过后的 DOM 数据。\r\n\r\n其内部调用 timerFunc 方法，优先使用微任务，然后宏任务，Promise => MutationObserver => setImmediate => setTimeout，其意愿总是尽快执行\r\n\r\n4. Vue.use\r\n\r\n负责为 Vue 安装插件，做了以下两件事：\r\n\r\n- 判断插件是否已经被安装，如果已安装则直接结束\r\n- 安装插件，执行插件的 install 方法\r\n\r\n5. Vue.mixin\r\n\r\n负责全局混入选项，影响之后所有创建的 Vue 实例，其作用是抽离公共的业务逻辑，当组件初始化的时候，会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。如果混入的数据和本身组件的数据有冲突，采用本身的数据为准。\r\n\r\n缺点：命名冲突、数据来源不清晰\r\n\r\n6. Vue.extend\r\n\r\n基于 Vue 去扩展子类，该子类同样支持进一步的扩展\r\n\r\n扩展时可以传递一些默认配置，就像 Vue 也会有一些默认配置，所以通过 Vue.extend 扩展一个子类，一大用处就是内置一些公共配置，供子类的子类使用\r\n\r\n默认配置如果和基类有冲突则会进行选项合并（mergeOptions)\r\n\r\n7. Vue.component\r\n\r\n负责注册全局组件。其实就是将组件配置注册到全局配置的 components 选项上（options.components），然后各个子组件在生成 vnode 时会将全局的 components 选项合并到局部的 components 配置项上。\r\n\r\n8. Vue.filter\r\n\r\n负责在全局注册过滤器。然后每个子组件在生成 vnode 时会将全局的 filters 选项合并到局部的 filters 选项中。\r\n\r\n9. Vue.directive\r\n\r\n在全局注册自定义指令。然后每个子组件在生成 vnode 时会将全局的 directives 选项合并到局部的 directives 选项中。"},"95d8":function(r,n,e){"use strict";e.r(n),n["default"]="## 如何编写vue插件\r\n\r\n收集中..."},9629:function(r,n,e){"use strict";e.r(n),n["default"]="## Class 与 Style 如何动态绑定？\r\n\r\n- 对象语法：\r\n\r\n```html\r\n<div v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"></div>\r\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\r\n<script>\r\n  data() {\r\n    return {\r\n      isActive: true,\r\n      hasError: false,\r\n      activeColor: 'red',\r\n      fontSize: 30\r\n    }\r\n  }\r\n<\/script>\r\n```\r\n\r\n- 数组语法：\r\n\r\n```html\r\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\r\n<div v-bind:style=\"[styleColor, styleSize]\"></div>\r\n<script>\r\n  data() {\r\n    return {\r\n       activeClass: 'active',\r\n       errorClass: 'text-danger',\r\n       styleColor: {\r\n        color: 'red'\r\n      },\r\n      styleSize:{\r\n        fontSize:'23px'\r\n      }\r\n    }\r\n  }\r\n<\/script>\r\n```"},"962e":function(r,n,e){"use strict";e.r(n),n["default"]="## vue eventbus 与 vuex 的区别\r\n\r\nxxxx"},"972d":function(r,n,e){"use strict";e.r(n),n["default"]="## position的值， relative和absolute分别是相对于谁进行定位的？\r\n\r\n- `relative`:相对定位，相对于自己本身在正常文档流中的位置进行定位。\r\n- `absolute`:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。\r\n- `fixed`: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。\r\n- `static`:默认值，没有定位，元素出现在正常的文档流中。\r\n- `sticky`:生成粘性定位的元素，容器的位置根据正常文档流计算得出。"},"9aca":function(r,n,e){"use strict";e.r(n),n["default"]="## BFC 是什么？\r\n\r\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\r\n可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\r\n只要元素满足下面任一条件即可触发 BFC 特性\r\n\r\n- body 根元素\r\n- 浮动元素：float 除 none 以外的值\r\n- 绝对定位元素：position (absolute、fixed)\r\n- display 为 inline-block、table-cells、flex\r\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)"},a045:function(r,n,e){"use strict";e.r(n),n["default"]='## Vue 组件通讯有哪几种方式\r\n\r\n1. props 和 $emit()，父组件使用 props 向子组件传递数据，子组件使用 $emit() 触发事件向父组件(使用v-on监听事件)传递数据。\r\n2. $parent 和 $childen，获取当前组件的父组件和子组件。\r\n3. $attrs 和 $listeners，A -> B -> C -> D，主要解决组件跨级通讯的问题。$attrs 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)，可以通过 v-bind="$attrs" 传入内部组件。$listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器，它可以通过 v-on="$listeners" 传入内部组件。子组件设置 inheritAttrs 属性为 false 将使 $attrs 不显性的绑定到元素上。\r\n4. ref 和 $refs 使用 ref 给组件设置名称，使用 $refs 获取组件实例。\r\n5. provide 和 inject，父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)。\r\n6. eventBus，事件总线，所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。导出一个 new Vue() 实例，使用 $on 注册事件和 $emit 触发事件。\r\n7. vuex 状态管理。\r\n8. localStorage 和 sessionStorage，本地存储。\r\n9. .aync 和 props，使用 `:page.sync="page"`向子组件传递数据，子组件使用 `props:["page"]` 接收数据，可实现数据的双向绑定。\r\n10. v-model 和 props，使用 `v-model="value"` 向子组件传递数据，子组件使用 `props:["value"]` 接收数据，可实现数据的双向绑定。\r\n11. $root，可以拿到 App.vue 里的数据和方法\r\n12. slot，就是把子组件的数据通过插槽的方式传给父组件使用，然后再插回来。'},a49d:function(r,n,e){"use strict";e.r(n),n["default"]="## iframe的优缺点？\r\n\r\n优点：\r\n\r\n- 解决加载缓慢的第三方内容如图标和广告等的加载问题\r\n- Security sandbox\r\n- 并行加载脚本\r\n\r\n缺点：\r\n\r\n- iframe会阻塞主页面的Onload事件\r\n- 即时内容为空，加载也需要时间\r\n- 没有语意"},a661:function(r,n,e){"use strict";e.r(n),n["default"]="## vue中slot时如何实现的\r\n\r\n1. slot 和 slot-scope 在组件内部被统一整合成了 函数\r\n2. 他们的渲染作用域都是 子组件\r\n3. 并且都能通过 this.$scopedSlots 去访问\r\n\r\n如果是 普通插槽，就直接调用函数生成 vnode，如果是 作用域插槽，就直接带着 props 也就是 { msg } 去调用函数生成 vnode。"},ac35:function(r,n,e){"use strict";e.r(n),n["default"]="## javascript的内存(垃圾)回收机制？\r\n\r\n- 垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存\r\n- 一般使用**标记清除方法(mark and sweep)**, 当变量进入环境标记为进入环境，离开环境标记为离开环境垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了\r\n- 还有**引用计数方法(reference counting)**, 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。\r\n- 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。"},afee:function(r,n,e){"use strict";e.r(n),n["default"]="## 组件跨级通讯有哪些\r\n\r\n常见使用场景可以分为三类：\r\n\r\n- 父子通信：`props`&`$emit`、`$parent`&`$children`、`ref`、 `provide`&`inject`、`$attrs`&`$listeners`\r\n- 兄弟通信：`Event Bus`、`Vuex`\r\n- 跨级通信：`Event Bus`、`Vuex`、`provide`&`inject`、`$attrs`&`$listeners`\r\n"},b5b9:function(r,n,e){"use strict";e.r(n),n["default"]="## vue3.0 用过吗 了解多少\r\n\r\n- 响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty\r\n- 组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。\r\n- 模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级\r\n- 其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 treeshaking 优化，提供了更多的内置功能。"},b6b3:function(r,n,e){"use strict";e.r(n),n["default"]="## MVC 和 MVVM 的区别，MVVM原理\r\n\r\nMVC\r\n\r\nMVC 全名是 Model View Controller，是模型(Model) - 视图(View) - 控制器(controller) 的缩写，是一种软件设计典范\r\n\r\n- Model 模型：用于处理数据逻辑的部分，模型对象通常负责在数据库中存取数据\r\n- View 视图：用于处理数据显示的部分，视图通常是依据模型数据建立的\r\n- Controller 控制器：用户处理用户交互的部分，控制器通常负责从视图读取数据，控制用户输入，并向模型发送数据\r\n\r\nMVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来。\r\n\r\nMVVM\r\n\r\nMVVM 新增了 VM 类\r\n\r\n- ViewModel 层：主要实现了数据的双向绑定，模型 - 视图，视图 - 模型的转换。\r\n\r\nMVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）"},c1a7:function(r,n,e){"use strict";e.r(n),n["default"]="## 移动端1px\r\n\r\n- 物理像素：移动设备出厂时，不同设备自带的不同像素，也称硬件像素；\r\n- 逻辑像素：即css中记录的像素。\r\n\r\n获取物理像素：\r\n\r\n- js：`window.devicePixelRatio`\r\n- 媒体查询：`-webkit-min-device-pixel-ratio`\r\n\r\n解决方案：\r\n\r\n- transform: scale(0.5) 缩放\r\n- viewport + rem `<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">`\r\n- 媒体查询利用设备像素比缩放，设置小数像素；(`@media screen and (-webkit-min-device-pixel-ratio: 2)`)\r\n- box-shadow 利用阴影\r\n- 设置 border-image 方案\r\n- background-image 渐变实现\r\n\r\n动态修改缩放比：\r\n\r\n```js\r\nvar viewport = document.querySelector(\"meta[name=viewport]\")\r\nif (window.devicePixelRatio == 1) {\r\n    viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')\r\n} \r\nif (window.devicePixelRatio == 2) {\r\n    viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')\r\n} \r\nif (window.devicePixelRatio == 3) {\r\n    viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')\r\n} \r\nvar docEl = document.documentElement;\r\nvar fontsize = 10 * (docEl.clientWidth / 320) + 'px';\r\ndocEl.style.fontSize = fontsize;\r\n```\r\n\r\nhttps://www.cnblogs.com/xgqfrms/p/13369752.html\r\n\r\nhttps://www.jianshu.com/p/31f8907637a6"},c1a74:function(r,n,e){"use strict";e.r(n),n["default"]="## 说说 vue 内置指令\r\n\r\n- `v-text` 更新元素的 textContent。\r\n- `v-html` 更新元素的 innerHTML，注意 XSS 攻击。\r\n- `v-show` 根据表达式之真假值，切换元素的 display 值。\r\n- `v-if/v-else-if/v-else` 根据表达式的值的 truthiness 来有条件地渲染元素。当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。\r\n- `v-for` 基于源数据多次渲染元素或模板块，注意增加唯一 key 值。\r\n- `v-on` 缩写`@`，绑定事件监听器，在普通元素上只能监听原生 DOM 事件，在自定义组件上可以监听子组件的自定义事件。\r\n- `v-bind` 缩写`:`，动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。\r\n- `v-model` 在表单控件或者组件上创建双向绑定。\r\n- `v-slot` 缩写`#`，提供具名插槽或需要接收 prop 的插槽。\r\n- `v-pre` 跳过这个元素和它的子元素的编译过程，以此来加快整个项目的编译速度。\r\n- `v-cloak` 这个指令保持在元素上直到关联实例结束编译，解决初始化慢导致闪动的最佳实践。\r\n- `v-once` 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。"},c2d2:function(r,n,e){"use strict";e.r(n),n["default"]="## 说说你对 SPA 单页面的理解，它的优缺点分别是什么？\r\n\r\nSPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\r\n\r\n- 优点：\r\n  - 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\r\n  - 基于上面一点，SPA 相对对服务器压力小；\r\n  - 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\r\n- 缺点：\r\n  - 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\r\n  - 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\r\n  - SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\r\n"},c54e:function(r,n,e){"use strict";e.r(n),n["default"]="## vue angular react 差异\r\n\r\nxxx"},c7b5:function(r,n,e){"use strict";e.r(n),n["default"]="## 组件的理解及渲染过程和更新流程\r\n\r\n1. 组件的理解\r\n\r\n- 组件化开发能大幅提高应用开发效率、测试性、复用性\r\n- 常用的组件化技术：属性、自定义事件、插槽\r\n- 降低更新范围，值重新渲染变化的组件\r\n- 高内聚、低耦合、单向数据流\r\n\r\n2. 组件的渲染流程和更新流程\r\n\r\n渲染组件时，会通过 vue.extend() 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载。更新组件时会进行 patchVnode 流程，核心就是 diff 算法。"},cbd7:function(r,n,e){"use strict";e.r(n),n["default"]="## vue如何编写组件\r\n\r\nxxx"},ce86:function(r,n,e){"use strict";e.r(n),n["default"]='## {} 和 [] 的 valueOf 和 toString 的结果是什么？\r\n\r\n- {} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"\r\n- [] 的 valueOf 结果为 [] ，toString 的结果为 ""'},cef4:function(r,n,e){"use strict";e.r(n),n["default"]="## v-model 原理\r\n\r\n我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\r\n\r\n- text 和 textarea 元素使用 value 属性和 input 事件；\r\n- checkbox 和 radio 使用 checked 属性和 change 事件；\r\n- select 字段将 value 作为 prop 并将 change 作为事件。"},d0d3:function(r,n,e){"use strict";e.r(n),n["default"]="## eval 是做什么的？\r\n\r\n- 它的功能是把对应的字符串解析成 JS 代码并运行；\r\n- 应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。"},d183:function(r,n,e){"use strict";e.r(n),n["default"]="## CSS3 里面都新增了那些新特性？\r\n\r\n- 2d，3d变换\r\n- Transition, animation 动画\r\n- 媒体查询\r\n- 新的单位（rem, vw，vh 等）\r\n- 圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜\r\n- rgba"},d381:function(r,n,e){"use strict";e.r(n),n["default"]="## 箭头函数与普通函数有什么区别？\r\n\r\n- 1、箭头函数不能作为构造函数（没有`constructor`）\r\n- 2、箭头函数没有原型（`prototype===undefined`）\r\n- 3、箭头函数 return 可以省略语句块。(如果 => 右边不是语句块，则代表 return 右边的表达式或对象)\r\n- 4、箭头函数没有 `arguments`\r\n- 5、this 指向问题\r\n  - 箭头函数的this指向上层函数作用域的this对象，如果没有上层函数作用域，则指向顶部this（在浏览器中顶部this则是window）。普通函数的this指向该函数的调用者。\r\n  - call, apply, bind 会改变普通函数的 this，但不会改变箭头函数的 this\r\n- 6、箭头函数内不能用 yield 且不能用作 Generator 函数"},d476:function(r,n,e){"use strict";e.r(n),n["default"]="## 简明说一下 CSS link 与 @import 的区别和用法？\r\n\r\n- link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。\r\n- link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。\r\n- link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。\r\n- link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。"},d6dd:function(r,n,e){"use strict";e.r(n),n["default"]="## 为什么 0.1+0.2 ! == 0.3，如何让其相等\r\n\r\n因为使用了 IEEE 754 数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。\r\n\r\n解决办法：\r\n\r\n```js\r\n// 换成别的数字\r\n(0.1*10+0.2*10)/10 === 0.3\r\n\r\n// 保留小数位数\r\nparseFloat((0.1+0.2).toFixed(10)) === 0.3\r\n```"},de48:function(r,n,e){"use strict";e.r(n),n["default"]="## ajax过程？\r\n\r\n- (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.\r\n- (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.\r\n- (3)设置响应HTTP请求状态变化的函数.\r\n- (4)发送HTTP请求.\r\n- (5)获取异步调用返回的数据.\r\n- (6)使用JavaScript和DOM实现局部刷新."},e4db:function(r,n,e){"use strict";e.r(n),n["default"]="## new 操作符具体干了什么呢？\r\n\r\n1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\r\n2. 属性和方法被加入到 this 引用的对象中。\r\n3. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。"},e670:function(r,n,e){"use strict";e.r(n),n["default"]="## 怎样理解 Vue 的单向数据流\r\n\r\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\r\n\r\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\r\n\r\n额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。\r\n\r\n这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\r\n\r\n子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。"},e8fa:function(r,n,e){"use strict";e.r(n),n["default"]="## 如何优化 JS 中过多的使用 IF 语句？\r\n\r\n六种替代 if 语句\r\n\r\n- 三元运算符 `where ? 1 : 2`\r\n- 短路运算符 `isAge && (age = 18)`\r\n- 函数委托 `where ? fun1() : fun2()`\r\n- 非分支策略 `list[where]()`\r\n- 作为数据的函数\r\n- 多态性"},e93a:function(r,n,e){"use strict";e.r(n),n["default"]="## keep-alive的原理\r\n\r\nkeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：\r\n\r\n- 一般结合路由和动态组件一起使用，用于缓存组件；\r\n- 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；\r\n- 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。\r\n\r\n- `include` 定义缓存白名单，keep-alive会缓存命中的组件；\r\n- `exclude` 定义缓存黑名单，被命中的组件将不会被缓存；\r\n- `max` 定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。\r\n\r\n- 获取 keep-alive 包裹着的第一个子组件对象及其组件名；\r\n- 根据设定的黑白名单（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例（VNode），否则执行第三步；\r\n- 根据组件 ID 和 tag 生成缓存Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置（更新key的位置是实现 LRU 置换策略的关键），否则执行第四步；\r\n- 在 this.cache 对象中存储该组件实例并保存 key 值，之后检查缓存的实例数量是否超过 max 的设置值，超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为0的那个 key）。\r\n- 最后，将该组件实例的 keepAlive 属性值设置为 true。"},ed2a:function(r,n,e){"use strict";e.r(n),n["default"]='## $attrs 是为了解决什么问题出现的？\r\n\r\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件——在创建高级别的组件时非常有用。\r\n\r\n主要作用是为了实现批量传递数据。\r\n\r\nprovide/inject更适合应用在插件中，主要实现跨级数据传递。\r\n\r\n`$attrs` 可以收集父组件中的所有传过来的属性除了那些在组件中没有通过 props 定义的。'},f0c7:function(r,n,e){"use strict";e.r(n),n["default"]="## 垂直居中几种方式？\r\n\r\n- 单行文本: line-height = height\r\n- 图片: vertical-align: middle;\r\n- absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);\r\n- flex: display:flex;margin:auto\r\n- 视口：width:50vw;height:50vh;margin:25vh auto;"},f499:function(r,n,e){"use strict";e.r(n),n["default"]="## 如何获取安全的 undefined 值？\r\n\r\n因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。"},f4bf:function(r,n,e){"use strict";e.r(n),n["default"]='## 任意类型到字符串、数字值、布尔值的转换规则？\r\n\r\n### 1、字符串\r\n\r\n- Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"。\r\n- Boolean 类型，true 转换为 "true"，false 转换为 "false"。\r\n- Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。\r\n- Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。\r\n- 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 `[[Class]]` 的值，如"`[object Object]`"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。\r\n\r\n### 2、数字值\r\n\r\n- Undefined 类型的值转换为 NaN。\r\n- Null 类型的值转换为 0。\r\n- Boolean 类型的值，true 转换为 1，false 转换为 0。\r\n- String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。\r\n- Symbol 类型的值不能转换为数字，会报错。\r\n- 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。\r\n\r\n为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。\r\n\r\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\r\n\r\n### 3、布尔值\r\n\r\n以下这些是假值： • undefined • null • false • +0、-0 和 NaN • ""\r\n\r\n假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。'},f9c9:function(r,n,e){"use strict";e.r(n),n["default"]="## css 布局，页面分三块左边 300 宽度、中间不固定宽度、右边 300 宽度，如何布局以及有哪几种实现方式？\r\n\r\n- `float`\r\n- `display: flex + flex:1`\r\n- `display: flex + calc`\r\n- `position: absolute`\r\n\r\n```css\r\n/* 第一种方式 */\r\n.main {\r\n  width: 100%;\r\n}\r\n.div1 {\r\n  width: 300px;\r\n  float: left;\r\n}\r\n.div2 {\r\n  float: left;\r\n}\r\n.div3 {\r\n  width: 300px;\r\n  float: right;\r\n}\r\n\r\n/* 第二种方式 */\r\n.main {\r\n  width: 100%;\r\n  display: flex;\r\n}\r\n.div1 {\r\n  width: 300px;\r\n}\r\n.div2 {\r\n  flex: 1;\r\n}\r\n.div3 {\r\n  width: 300px;\r\n}\r\n\r\n/* 第三种方式 */\r\n.main {\r\n  width: 100%;\r\n  display: flex;\r\n}\r\n.div1 {\r\n  width: 300px;\r\n}\r\n.div2 {\r\n  width: calc(100% - 600px);\r\n}\r\n.div3 {\r\n  width: 300px;\r\n}\r\n\r\n/* 第四种方式 */\r\n.main {\r\n  width: 100%;\r\n  position: relative;\r\n}\r\n.div1 {\r\n  width: 300px;\r\n  position: absolute;\r\n  left: 0;\r\n}\r\n.div2 {\r\n  position: absolute;\r\n  left: 300px;\r\n}\r\n.div3 {\r\n  width: 300px;\r\n  right: 0;\r\n  position: absolute;\r\n}\r\n```\r\n"},fbdb:function(r,n,e){"use strict";e.r(n),n["default"]="## href 与 src？\r\n\r\n- `href` (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）\r\n- `src` source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。\r\n\r\nhref与src的区别\r\n\r\n1. 请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；\r\n2. 作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；\r\n3. 浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。"}}]);